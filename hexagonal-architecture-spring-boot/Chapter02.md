# 2장. 의존성 역전하기
1징에서 계층형 아키텍처에 대한 불만이 많았는데, 2장에서는 그 대안에 대해서 알아보자.

## 단일 책임 원칙
단일 책임 원칙의 일반적인 해석은 다음과 같다.
`하나의 컴포넌트는 오로지 한가지 일만 해야 하고, 그것을 올바르게 수행해야 한다`

이는 단일 책임 원칙의 실제 의도는 아니다. 단일 책임 원칙의 실제 의도는 다음과 같다.
`컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.`

만약 컴포넌트를 변경할 이유가 오로지 한 가지 라면 컴포넌트는 딱 한 가지 일만 하게 된다.
-> 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 한 가지 일만 하는 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.
-> 하지만 변경할 이유 라는건 컴포넌트 간의 **의존성** 을 통해 너무도 쉽게 전파된다.

**의존성이 많은 컴포넌트는 그만큼 변경할 이유도 많아진다.**

## 부수효과에 관한 이야기
잘못 구조화된 소프트웨어를 변경하는 데는 많은 비용과 노력이 들어간다.

## 의존성 역전 원칙
계층형 아키텍처에서 의존성은 항상 아래 방향을 가리킨다.
-> 상위 계층이 하위 계층에 비해 더 변경할 이유가 많다.
-> 영속성 코드를 변경하면, 도메인 코드를 변경해야 한다.
이렇게 되지 않으려면, **영속성 코드가 도메인 코드에 의존하게 하면 된다.**

도메인 계층에 Repository 에 대한 인터페이스를 만들고, 실제 Repository 는 영속성 계층에서 구현하게 하면 된다.

## 클린 아키텍처
클린 아키텍처는 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.
클린 아키텍처의 코어에는 유스케이스들에서 접근하는 **도메인 엔티티**들이 있다.
도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없다.
-> 때문에 더욱더 비즈니스 규칙에 집중할 수 있다.
-> 단점은 영속성, UI 같은 외부 계층과 철저하게 분리 되어야 하므로 각 계층에서 모델 클래스를 유지보수 해야 한다.

## 육각형 아키텍처 (헥사고날 아키텍처)
클린 아키텍처의 원칙들을 적용해 좀 더 구체적인 육각형 아키텍처를 살펴보자.

육각형이던, 팔각형이던 중요하지 않다 중요한거는 육각형 외부로 향하는 의존성이 없고, 그 중심에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 클린 아키텍처 처럼 모든 의존성은 코어를 향한다.

육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터 들이 있지만, 육각형 내부에서는 구체적으로 어떤 어댑터와 상호작용 하는지 모른다.

어플리케이션 코어와 어댑터는 포트를 통해 통신한다.
Driving adapter 는 포트를 호출하고, Driven adapter 는 포트를 구현할 것이다.

## 정리
클린 아키텍처든 육각형 아키텍처던 포트와 어댑터 아키텍처던 중요한건 의존성을 역전 시켜서 조메인 코드가 다른 바깥쪽 코드에 의존하지 않게 하는 것이다.
-> 영속성, UI 와 도메인 로직을 분리시켜 코드를 변경할 이유의 수를 줄일 수 있다.
-> 도메인 로직이 분리가 되니 비즈니스 요구사항에 딱 맞도록 모델링 될 수 있고 테스트가 용이 하다.









#책정리/만들면서_배우는_클린아키텍쳐 